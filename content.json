{"meta":{"title":"trtan","subtitle":"trtan的技术博客","description":"学习永无止境","author":"trtan","url":"http://tanruidd.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-05-26T07:59:29.000Z","updated":"2020-06-14T00:30:14.562Z","comments":true,"path":"about/index.html","permalink":"http://tanruidd.github.io/about/index.html","excerpt":"","text":""},{"title":"board","date":"2019-05-26T07:43:43.000Z","updated":"2019-05-26T07:46:56.254Z","comments":true,"path":"board/index.html","permalink":"http://tanruidd.github.io/board/index.html","excerpt":"","text":"哈哈"}],"posts":[{"title":"leetcode-2020-7-15","slug":"leetcode-2020-7-15","date":"2020-07-15T12:30:57.000Z","updated":"2020-07-15T12:45:59.072Z","comments":true,"path":"2020/07/15/leetcode-2020-7-15/","link":"","permalink":"http://tanruidd.github.io/2020/07/15/leetcode-2020-7-15/","excerpt":"","text":"LeetCode 2020年7月15日一、leetcode-5431、题目大意给定一颗二叉树，求出树中最长的那条路径长度。 例如：对于下列这颗树，最长路径为3，[4,2,1,3]或[5,2,1,3]，路径长度是边的个数。 12345 1 / \\ 2 3 / \\ 4 5 2、思路对每颗子树求得最长路径取最大值。 对于指定某个根的树来说，求经过该根节点的最长路径就是分别求该根结点到左右子树叶子结点的最长路径。 3、代码12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; int Max; //取所有子树的最长路径 public int diameterOfBinaryTree(TreeNode root) &#123; if (root == null)return 0; Max = 0; solve(root); return Max; &#125; int solve(TreeNode root) &#123; if (root == null)return 0; int a = solve(root.left); int b = solve(root.right); Max = Math.max(Max, a + b); //更新最大值 return Math.max(a, b) + 1; //返回左右子树中长的那一条路径的长度 &#125;&#125; 二、leetcode-13251、题目大意给定一颗二叉树和一个target，删除该二叉树中叶子节点值为target的所有结点。 如：root = [1,2,3,2,null,2,4], target = 2 则最后树为[1,null,3,null,4]。 2、思路遍历二叉树，需采用后序遍历，对叶子结点进行判断，判断叶子结点值是否为target，若是更改它的父节点对应的左右结点为null。 3、代码1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode removeLeafNodes(TreeNode root, int target) &#123; //设置一个父结点，将树根结点作为其左结点或右结点，因为可能存在所有结点均被删除 TreeNode parent = new TreeNode(-1); parent.left = root; solve(parent, root, target); return parent.left; &#125; public void solve(TreeNode parent, TreeNode root, int target) &#123; if (root == null) return; solve(root, root.left, target); solve(root, root.right, target); //如果该结点为叶子结点且值为target，则找到它对应是parent的左儿子还是右儿子 if (root.val == target &amp;&amp; root.left == null &amp;&amp; root.right == null) &#123; if (parent.left == root)parent.left = null; else parent.right = null; &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://tanruidd.github.io/tags/leetcode/"}]},{"title":"leetcode-1368","slug":"leetcode-1368","date":"2020-07-14T12:40:31.000Z","updated":"2020-07-14T13:11:35.433Z","comments":true,"path":"2020/07/14/leetcode-1368/","link":"","permalink":"http://tanruidd.github.io/2020/07/14/leetcode-1368/","excerpt":"","text":"leetcode1368-Minimum Cost to Make at Least One Valid Path in a Grid1、题目大意给定m*n个格子，grid[m][n]，对于每个格子grid[i][j]值为1~4 1代表往右走，即下一个格子为grid[i][j + 1] 2代表往左走，即下一个格子为grid[i][j - 1] 3代表往下走，即下一个格子为grid[i + 1][j] 4代表往上走，即下一个格子为grid[i - 1][j] 问，从grid[0][0]走到grid[m - 1][n - 1]最少需要改变多少个格子的方向。 这个例子需要至少改变三个格子的方向，如(0,0)，(1,0)，(2,3)这三个格子的方向。 范围： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 100 2、思路分析此题，要求从左上角走到左下角，那么需要改变的格子数量最多不会超过m+n个。 每个格子可能从四个方向过来最短，那么对每个格子求从(0,0)位置到自己位置的最短路，再不断更新最小值。 通过bfs，首先将(0,0)位置加入队列，再更新相邻格子的最小值即可，直到无法更新即求得到(m-1,n-1)位置的最小值。 3、代码123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int minCost(int[][] grid) &#123; final int INF = 1000; //四个方向，这里左、右、下、上下标大小与题目方向1、2、3、4大小均相差1，方便进行运算 int dx[] = &#123;0, 0, 1, -1&#125;; int dy[] = &#123;1, -1, 0, 0&#125;; int res = 0; int m = grid.length; int n = grid[0].length; int dis[][] = new int[m][n]; //初始化距离 for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; dis[i][j] = INF; &#125; &#125; dis[0][0] = 0; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]&#123;0, 0&#125;); while (!queue.isEmpty()) &#123; int[] p = queue.poll(); for (int i = 0; i &lt; 4; i++) &#123; int nx = p[0] + dx[i]; int ny = p[1] + dy[i]; if(nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n) &#123; int d = 0; //判断x=p[0],y=p[1]到nx,ny位置是否需要改变方向 //grid[p[0]][p[1]] - i 为1则说明方向一致，不需要改变 if(grid[p[0]][p[1]] - i != 1) d = 1; if(dis[nx][ny] &gt; dis[p[0]][p[1]] + d) &#123; dis[nx][ny] = dis[p[0]][p[1]] + d; queue.offer(new int[]&#123;nx, ny&#125;); &#125; &#125; &#125; &#125; return dis[m - 1][n - 1]; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://tanruidd.github.io/tags/leetcode/"}]},{"title":"leetcode42-Trapping Rain Water","slug":"leetcode42-Trapping-Rain-Water","date":"2020-07-04T12:51:17.000Z","updated":"2020-07-04T14:12:25.753Z","comments":true,"path":"2020/07/04/leetcode42-Trapping-Rain-Water/","link":"","permalink":"http://tanruidd.github.io/2020/07/04/leetcode42-Trapping-Rain-Water/","excerpt":"","text":"LeetCode42-Trapping Rain Water1、题目大意给定n个非负整数，每个整数代表墙的高度，墙于墙凹泄处可以装雨水，问能装几个单位的雨水。 例如：[0,1,0,2,1,0,1,3,2,1,2,1]，答案为6 例如：[4,2,1,0,3,1,2,5]，答案为15 2、思路分析题目，目的是要求出所有凹槽大小和。 那么我的想法是这样的，设置一个单调递减栈。 1、如果当前压入栈的元素小于栈顶元素，即直接将该元素加入栈。 2、如果当前压入栈的元素大于栈顶元素，即需要更新栈内元素，不断弹出栈顶元素直到栈顶元素大于当前元素大小或栈为空。那么在弹出时计算已填充墙的大小，再用总面积减去墙的大小。 3、代码12345678910111213141516171819202122232425262728293031class Solution &#123; struct Node &#123; int val; int index; &#125;;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); Node sta[n + 5]; int ans = 0; int l, r; int tail = -1; for(int i = 0; i &lt; n; i++) &#123; int sum = 0; l = -1; r = i; while(tail &gt; -1 &amp;&amp; height[i] &gt;= sta[tail].val) &#123; tail--; if(tail == -1)break; sum += (sta[tail + 1].index - sta[tail].index) * sta[tail + 1].val; l = sta[tail].index; &#125; if(l != -1) &#123; ans += (r - l - 1) * min(height[i], height[l]) - sum; &#125; sta[++tail].val = height[i]; sta[tail].index = i; &#125; return ans; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://tanruidd.github.io/tags/leetcode/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2020-06-13T09:10:08.000Z","updated":"2020-06-13T09:47:08.000Z","comments":true,"path":"2020/06/13/正则表达式/","link":"","permalink":"http://tanruidd.github.io/2020/06/13/正则表达式/","excerpt":"","text":"正则表达式1、什么是正则表达式？正则表达式是使用字符串去描述一个匹配规则。 使用正则表达式可以快速判断给定的字符串是否符合匹配规则。 Java内建正则表达式引擎java.util.regex： 2、匹配规则从左到右按规则匹配。 字符 样例 说明 “abc” 精确匹配”abc” “a\\&amp;c” 精确匹配”a&amp;c”，特殊字符需转义字符’\\‘修饰，java字符串还需两次转义’\\\\&amp;’ \\uxxxx “a\\u548c’ ‘\\uxxxx’可以匹配指定的Unicode字符，如”a和c” . “a.c” ‘.’可以匹配一个任意字符，如”abc”、”a&amp;c”等 \\S “a\\Sb” ‘\\s’可以匹配一个非空白字符，如”a#b”、”a2b”、”a_c”等 \\s “a\\sb” ‘\\s’可以匹配一个空白字符（空格、tab等），如”a b”、”a b”等 \\D “00\\D” ‘\\D’可以匹配一个非数字字符，如”00x”、”00A”、”00 “等 \\d “00\\d” ‘\\d’可以匹配一个数字字符（0~9），如”001”、”008”等 \\W “java\\W” ‘\\W’可以匹配一个非字母、数字、下划线字符，如”java “、”java#”等 \\w “java\\w” ‘\\w’可以匹配任何字符类字符（字母、数字），包括下划线，如”java8”、”java_”等 * “AB*” ‘*’修饰前面一个字符，可以匹配任意个字符，如”AB”、”ABBBB”等 + “AB+” ‘+’修饰前面一个字符，可以匹配至少一个字符，如”AB”、”ABBB”等 ? “AB?” ‘?’修饰前面一个字符，可以匹配一个或零个字符，如”A”、”AB” {n} “A{3}B” ‘{n}’修饰前面一个字符，可以匹配n个字符，如”AAAB” {n,m} “A{2,4}B” ‘{n,m}’修饰前面一个字符，可以匹配n~m个字符，如”AAB”、”AAAB”、”AAAAB” {n,} “A{3,}B” ‘{n,}’修饰前面一个字符，可以匹配至少n个字符，如”AAAB”、”AAAAB”等 \\B “P\\BAP” ‘\\B’可以匹配字符与字符、符号与符号的边界，如”PAP” \\b “,\\bAP” ‘\\b’可以匹配字符与符号的边界，如”,AP” 3、分组匹配可以使用()来对所匹配的字符串进行分组。 例如： 提取年月日： (\\d{4})\\-(\\d{1,2})\\-(\\d{1,2}) 可以将年-月-日给提取出来： “2020-5-31” -&gt; “2020”、”5”、”31”。 提取电话号码 ###-######## ^(\\d{3,4})-(\\d{6,8})$ ^表示开头 \\d{3,4}即3-4位区号 \\d{6,8}即6-8位电话号码 $表示结束 在Java中： 1String regex = \"^(\\\\d&#123;3,4&#125;)\\\\-(\\\\d&#123;6,8&#125;)$\"; 提取24小时时间 ##:## ^([0-1][0-9]|2[0-3])\\:([0-5][0-9])$ [0-1][0-9]表示0~19，然后|表示或，2[0-3]表示20~23，即一共24小时 [0-5][0-9]则为0~59，共60秒 1String regexTime = \"^([0-1][0-9]|2[0-3]):([0-5][0-9])$\"; 123456789101112131415161718192021222324252627282930313233343536373839package com.trtan.regex;import com.sun.org.apache.xerces.internal.impl.xpath.regex.Match;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; //yyyy-mm-dd String regexY = \".*^(\\\\d&#123;4&#125;)\\\\-(\\\\d&#123;1,2&#125;)\\\\-(\\\\d&#123;1,2&#125;)$\"; //xxxx-yyyyyyyy String regex = \"^(\\\\d&#123;3,4&#125;)\\\\-(\\\\d&#123;6,8&#125;)$\"; //hh:mm String regexTime = \"^([0-1][0-9]|2[0-3]):([0-5][0-9])$\"; Pattern pattern = Pattern.compile(regexY); Matcher matcher = pattern.matcher(\"2014-12-21\"); if(matcher.matches()) &#123; System.out.println(matcher.group(1)); System.out.println(matcher.group(2)); System.out.println(matcher.group(3)); &#125; Pattern pattern1 = Pattern.compile(regex); Matcher matcher1 = pattern1.matcher(\"086-13845785\"); if (matcher1.matches()) &#123; System.out.println(matcher1.group(1)); System.out.println(matcher1.group(2)); &#125; Pattern pattern2 = Pattern.compile(regexTime); Matcher matcher2 = pattern2.matcher(\"21:45\"); if (matcher2.matches()) &#123; System.out.println(matcher2.group(1)); System.out.println(matcher2.group(2)); &#125; &#125;&#125; 正则表达式分组，可以通过Matcher对象快速提取子串。 group(0)表示匹配整个字符串，group(1)表示匹配第一个子串，… 4、复杂匹配规则 字符 样例 说明 ^和$ ^A\\d{3}$ ‘^’和’$’代表匹配的开头和结尾，如：A123、A845等 […] [abc]1 […]可以匹配范围内的一个字符，如：a1、b1、c1 [a-f]1 如：a1、b1、d1等 [a-f0-9_]{6} […]{n}可以匹配范围内的n个字符，如：123f_45、aaacda、123485等 [^…] [^0-9]{6} [^…]{n}可以匹配非范围内的n个字符，如ffffff、AOj_s-、hoodss等 &#124; AB&#124;CD &#124;或运算，可以匹配多个条件的任意一个，如AB、CD \\n (\\d+)(a)\\1 ‘\\n’表示与第n组括号里的内容相同，如123a123，584a584等 （补一个MarkDown的问题：要用&amp;#124 ; 表示制表符&#124;） 5、非贪婪匹配如果想实现一个这样的匹配： 给定一个数字字符串，找出末尾连续0的个数，比如： 1320000，4个0 1024000，3个0 124，0个0 那么使用^(\\d+)(0*)$去匹配，结果是(\\d+)将字符串全部匹配了，(0*)只能匹配空串。 这是因为正则默认使用贪婪匹配，尽可能的向后匹配。 用?来实现非贪婪匹配，即改为^(\\d+?)(0*)$去匹配。就会尽可能少的去匹配。 1234567891011String str = \"^(\\\\d??)(9*)$\";Pattern pattern4 = Pattern.compile(str);Matcher matcher4 = pattern4.matcher(\"9999\");if(matcher4.matches()) &#123; System.out.println(matcher4.group(1)); System.out.println(matcher4.group(2));&#125;/*9999*/ 对于9999，第一个？表示匹配0个或1个数字，第二个？表示非贪婪匹配，就会按照最少的来匹配，即匹配0个，让后面那组匹配的数量更多一点。 6、搜索和替换 分割字符串 123456789//把字符串拆为数组//初始字符串格式很不规范String example = \"1, 2; 3, 4. 5, 6, 7, 8, 9\";String[] array_s = example.split(\"[,.;\\\\s]+\");Integer[] array = new Integer[array_s.length];for (int i = 0; i &lt; array.length; i++) &#123; array[i] = Integer.parseInt(array_s[i]); System.out.println(array[i]);&#125; 搜索子串 Matcher.find() 12345678//搜索text中的SpringString text = \"Mock Objects, TestContext Framework, Spring MVC Test, WebTestClient. Spring NB\";Pattern pattern5 = Pattern.compile(\"Spring\");Matcher matcher5 = pattern5.matcher(text);while (matcher5.find()) &#123; String sub = text.substring(matcher5.start(), matcher5.end()); System.out.println(sub);&#125; 替换字符串 String.replaceAll() 1234//比如要去掉text的所有空格，使用' '分割所有单词，然后对每个单词加粗(&lt;br&gt;&lt;/br&gt;包裹)String text = \"Mock Objects, TestContext Framework, Spring MVC Test, WebTestClient. Spring NB\";System.out.println(text.replaceAll(\"[\\\\s,.]+\", \" \") .replaceAll(\"(\\\\w+)\", \"&lt;br&gt;$1&lt;/br&gt;\")); 7、正则表达式练习网站https://alf.nu/RegexGolf 第一题： 1foo 第二题： 以k结尾，可使用”$”，也可使用”\\b”表示字符与符号的边界 12k$k\\b 第三题： 以u结尾，但是不允许使用 $ ，那就只能”\\b” 1u\\b 第四题： 左边前四位为a-f的字母，右边不符合。 12^[a-f]*$^[a-f]&#123;4&#125; 第五题： 新知识：“\\n”表示与第n组括号里的内容相同，如123a123，584a584等 左边前三位与中间三位相同 1^(...).*\\1 第六题： 右边有四位的回文串（abba、otto等） 新知识： 字符 样例 说明 (?:pattern) industr(?:y&#124;ies) 不获取匹配结果，不进行存储，可以代替”industry&#124;industries” (?=pattern) Windows(?=95&#124;98) 能匹配Windows98、Windows95中的Windows (?!pattern) Windows(?!95&#124;98) 能匹配Windows2020中的Windows (?&lt;=pattern) (?&lt;=95&#124;98)Windows 能匹配98Windows、95Windows中的Windows (?&lt;pattern) (?&lt;95&#124;98)Windows 能匹配2020Windows中的Windows 从上面表中可以知道，”?=”和”?!”可以用来前瞻匹配，题目要求的是排除回文串，那么使用”?!”。 首先回文串很容易写(.)(.)\\2\\1。 然后^(?!(.)(.)\\2\\1)这个意思就是不以回文开头，发现右边好多匹配的。 于是^(?!.*(.)(.)\\2\\1)允许有前缀，就可以干掉右边匹配的了。 1^(?!.*(.)(.)\\2\\1) 第七题： 发现左边首尾相同且为回文串，右边没有这个特征。 1^(.)(.).*\\2\\1$","categories":[{"name":"Java","slug":"Java","permalink":"http://tanruidd.github.io/categories/Java/"}],"tags":[{"name":"Java正则","slug":"Java正则","permalink":"http://tanruidd.github.io/tags/Java正则/"}]},{"title":"知识点总结","slug":"知识点总结","date":"2019-09-20T07:34:43.000Z","updated":"2019-09-24T13:22:49.974Z","comments":true,"path":"2019/09/20/知识点总结/","link":"","permalink":"http://tanruidd.github.io/2019/09/20/知识点总结/","excerpt":"","text":"数据库： 数据库系统特点：数据结构化、数据独立性高、数据共享性高、冗余性低、易扩展，由DBMS统一管理控制。 事务是DBMS的基本单位，是用户定义的一组逻辑一致的程序序列。 JAVA Java类的构造方法：构造方法是一种特殊的方法，它必须具备和所在类相同的名字，没有返回值类型，构造方法是在创建一个对象使用new操作符时调用的，作用是初始化对象。 图 连通图：连通图中的任意两顶点互达。 连通分量：无向图的极大连通子图。 类 修饰符访问规则 加密 公钥密码体制：加密和解密采用不同的密钥。对于传统对称密码而言，密文的安全性完全依赖于密钥的保密性，一旦密钥泄漏，将毫无保密性可言。公钥密码体制中，密钥是公开的，只有私钥是需要保密的。知道公钥和密码算法要推测私钥在计算上是不可行的，这样只要私钥是安全的那么加密就是安全的。 网络1、MAC地址长度为48比特。 2、OSI分层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 3、TCP/IP分层：网络接口层、网际层、运输层、应用层。 4、五层协议：物理层、数据链路层、网络层、运输层、应用层。 OSI七层协议大白话解读 物理层 实现计算机之间通信底层物理方面的连通，中间的物理链接可以是光缆、电缆、双绞线、无线电波。 传输的是电信号，即0100…这些二进制串。 如果要让这些01串有意义，那么必须把电信号做分组，例如8位一组，分组的实现就是数据链路层做的事。 数据链路层 以太网协议EtherNet规定 一组电信号称为一个数据包，或者叫做一个帧。 每一个数据帧分成：报头(head)和数据(data)两部分。 报头包含（固定18字节，一个字节8位）： 源地址，6个字节 目的地址，6个字节 数据类型，6个字节 数据包含（最短46字节，最长1500字节）： 数据包的具体内容 那么 报头长度+数据长度=最短64字节，最长1518字节，超过最大限制就分片发送。 源地址和目的地址都是指MAC地址。 MAC地址即网卡的地址（EtherNet规定接入Intenet的设备必须具备网卡）。 每块网卡上的一个唯一的MAC地址，长度为48位2进制，通常由12位16进制数表示，前六位代表厂商编号，后六位是流水线号。 有了MAC地址计算机就可以通信了，在一个局域网内，计算机之间通过广播的方式进行通信，即将源地址、目的地址及数据构成一个数据帧，通过广播的方式发送出去，那么所有其它机器都会接收到这个包，都会拆开包查看目的地址是否是自己，只要不是自己就丢弃掉。那么接收到的机器以同样的方式发送数据帧，实现计算机之间的通信。 但是全世界并不是一个局域网，也不可能是一个局域网，所以就有了网络层。 网络层 MAC地址是用来标识计算机在某个局域网的具体位置，IP地址则是标识计算机在哪个局域网。比如要访问百度，肯定要知道百度的ip地址，计算机在发包之前会判断你在哪个局域网，对方在哪个局域网，如果处于同一局域网，基于mac地址的广播发包就可以了。如果不在同一局域网下，那么就会把你个包交给网关来转发。MAC地址和IP地址唯一标识了你在互联网中的位置。 数据链路层会把网络层的数据包封装到数据链路层的数据位置，再加上自己的包头，再发给物理层，物理层发给网关，网关再发送给对方局域网的网关，对方网关在那个局域网做广播。 在数据链路层看，数据封装了两层： 那么在广播之前如何知道对方的MAC地址，这就得靠ARP协议。 在获取对方的MAC地址之前，首先需要发送一个ARP包，ARP也是靠广播的方式发，如下： 在局域网中，获取对方MAC地址： 首先需要知道对方的IP地址，自己的IP以及MAC地址都能得到，目标MAC为12个F，称之为广播地址。意思就是想要获取172.16.10.11的机器的MAC地址，计算机的MAC地址永远不可能是12个F，假设在一个局域网内广播，所有机器都会开始解包，但是只有172.16.10.11这个机器才会返回它的MAC地址，发回来的源MAC改成它自己的MAC地址，同时把自己的MAC地址放入数据部分。 跨网络获取对方的MAC地址： 通过IP地址区分，计算机判断目标地址不再同一个局域网下，目标IP就变成了网关IP了，网关IP可以在计算机上获取 这样网关就会把它的MAC地址给你，然后正常发包： 网关帮你去找目标用户，但是用户根本就感觉不到。 传输层 网络层的IP用于区分子网，MAC帮助找到主机，然后大家使用的都是应用程序，那么你的电脑可能同时开启多个应用程序，比如QQ、微信等。 那么我们通过IP和MAC找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口。端口即为应用程序与网卡关联的编号。 传输层功能就是建立端口到端口的通信。 端口范围：0~65535，0~1023为系统占用端口。 TCP协议 可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 UDP协议 不可靠传输，“报头”一共只有8个字节，总长度不超过65535字节，正好放入一个IP数据包。 应用层 用户使用的都是应用程序，均工作与应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式。 功能：规定应用程序的数据格式。 比如：TCP协议可以为各种各样的程序传递数据，比如Email、www、FTP等，那么必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了应用层。 5、计算机内的传输是并行传输，而通信线路上的传输是串行传输。 6、在操作系统中，一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的。 并发：在同一个时间段内，两个或多个程序执行，有时间上的重叠（宏观上是同时，微观上仍是顺序执行），也可以说是多个线程的轮流执行（单核CPU）。 并行：多个线程同时执行（多核CPU），微观上是同时的。 串行：就是一个一个执行，处理完一个才能处理下一个。 7、中继器：是工作在物理层的连接设备，适用于完全相同两类网络的互连，主要功能是通过对数据信号的重新发送或转发，来扩大网络传输的距离。 8、各层设备 物理层：转发器、集线器。 数据链路层：适配器、网桥。 网络层：路由器。 第三层以上的功能都是由软件实现，没有硬件设备与之对应。 操作系统1、设计现代操作系统的主要目标是什么？ 方便性、有效性、可扩充性、开发性。 2、树形目录解决了文件的重名问题，可以在不同目录下建立相同文件名的文件。 3、在虚拟内存管理中，地址变换机构将逻辑地址变为物理地址，形成该逻辑地址的阶段是链接。 以C语言为例：C语言经过预处理、编译、汇编、链接、生成可执行文件。其中链接的前一步产生了可重定位的二进制目标文件。 C语言采用源文件独立编译的方式，如程序main.c、file1.c、file2.c、file1.h、file2.h，在链接前一步生成了main.0、file1.o、file2.o，链接器将这三个文件和其它库文件链接成一个可执行文件。链接阶段完成了重定向，形成了逻辑的地址空间。 4、Linux的虚拟内存空间 为了防止不同进程在同一时刻在物理内存中运行而对物理内存的争夺，采用了虚拟内存。 虚拟内存技术使得不同进程在运行过程中，它看到的是自己独自占用了当前系统的内存。所有进程共享同一物理内存，每个进程只是把自己目前需要的虚拟内存空间映射并存储到物理地址上。事实上，在每个进程创建的时候，内核只是为进程创建了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的数据和代码拷贝到物理内存中，只是建立好虚拟内存和物理内存之间的映射，等到运行对应程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中要动态分配内存，如malloc、new，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才发生缺页异常。","categories":[],"tags":[]},{"title":"","slug":"网站部署","date":"2019-09-01T06:22:39.650Z","updated":"2019-09-01T10:57:14.797Z","comments":true,"path":"2019/09/01/网站部署/","link":"","permalink":"http://tanruidd.github.io/2019/09/01/网站部署/","excerpt":"","text":"Linux网站部署部署Apache环境:CentOS 7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869更新操作系统yum clean allyum -y update安装apacheyum -y install httpd启动apache设置开机自启:systemctl enable httpd.service启动:systemctl start httpd.service打开浏览器访问云主机ip地址可看到apache测试页面配置虚拟主机将文件放入/var/www目录下mkdir -p /var/www/edu.cloud.tencent.com/public_html修改属主 权限chown -R apache:apache /var/www/edu.cloud.tencent.com/public_htmlchown -R 755 /var/www创建首页文件,作为测试vim /var/www/edu.cloud.tencent.com/public_html/index.html创建apatch配置文件一般将apache配置文件放在两个目录中,一个目录放置所有的apache文件,另一个放置启用虚拟主机的apache文件.创建两个目录mkdir /etc/httpd/sites-availablemkdir /etc/httpd/sites-enabled修改默认配置文件vim /etc/httpd/conf/httpd.conf在最后一行加入:IncludeOptional sites-enabled/*.conf表示加载sites-enabled下的conf文件创建虚拟主机的配置文件vim /etc/httpd/sites-available/edu.cloud.tencent.com.conf输入以下内容:&lt;VirtualHost *:80&gt; ServerName edu.cloud.tencent.com DocumentRoot /var/www/edu.cloud.tencent.com/public_html ErrorLog /var/www/edu.cloud.tencent.com/error.log CustomLog /var/www/edu.cloud.tencent.com/requests.log combined&lt;/VirtualHost&gt;使用软链接连接配置文件ln -s /etc/httpd/sites-available/edu.cloud.tencent.com.conf /etc/httpd/sites-enabled/edu.cloud.tencent.com.conf可以检测新的软链接是否正常cat /etc/httpd/sites-enabled/edu.cloud.tencent.com.conf以及检查DocumentRoot配置是否正确cd /var/www/edu.cloud.tencent.com/public_html/ls重启apacheapachectl restart然后打开浏览器,访问对应地址就能看到index.html的页面了. 部署Nginx环境: CentOS 7 注意:在配置完成虚拟主机后,需要执行nginx -t,检测配置文件是否正确,然后使用service nginx reload重启Nginx. 1234567891011121314151617181920212223242526272829303132安装 epelyum install epel-release -y安装Nginxyum -y install nginx启动Nginxsystemctl start nginx.service打开浏览器访问云主机ip地址,可访问默认位置创建网站根目录,这里使用Apache的根目录mkdir -p /var/www/edu.cloud.tencent.com/public_htmlvim /var/www/edu.cloud.tencent.com/public_html/index.html修改配置文件vim /etc/ngnix/conf.d/virtual.conf添加如下代码server&#123; listen 80; //监听端口 server_name edu.cloud.tecent.com; //对应主机名 root /var/www/edu.cloud.tecent.com/public_html; //网站根目录 index index.html; //默认页面s&#125;检查配置文件是否正常nginx -t重启nginxsystemctl restart nginx.service访问对应地址 部署MySQL环境：CentOS 7 注意事项：安装完成后，要配置mysql密码，并进行mysql_secure_installtion，以免出现安全问题。 配置完成后可以执行show databases;查看MySQL是否配置成功。 1234567891011121314151617181920212223安装mariadb，在CentOS7中使用了mariadb替代了官方的MySQLyum install mariadb-server -y启动MySQL数据库systemctl start mariadb.service进行安全配置mysql_secure_installation输入默认密码，默认为空，直接回车设置用户密码，按y输入两次密码是否删除匿名用户关闭root用户的远程登录是否删除测试数据库，和相关权限是否刷新权限mysql -uroot -p输入密码查看数据库show database;退出数据库exit; 部署Laravel123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354安装第三方仓库yum instal epel-release安装webtatic仓库，包含php7rpm -Uvh https://mirror.webtatic.com/yum/e17/webtatic-release.rpmyum update按照php7一系列拓展yum install -y php70w php70w-mysql php70w-mcrypt php70w-dom php70w-mbstring安装composercurl -sS https://getcomposer.org/installer | php移动到系统目录mv composer.phar /usr/bin/composer添加执行权限chmod +x /usr/bin/composer查看composer信息composer -V配置国内镜像composer config -g repo.packagist composer https://packagist.phpcomposer.com配置Laravel环境cd /var/www展示apache目录下的文件ls创建laravel项目composer create-project laravel/laravel test查看ll修改test目录权限chown apache:apache -R test修改配置文件vim /etc/httpd/conf.d/test.conf修改如下：&lt;VirtualHost *:80&gt; ServerName test.cloud.tencent.com DocumentRoot /var/www/test/public&lt;/VirtualHost&gt;重启apachesystemctl restart httpd打开浏览器测试网站 部署Django注意事项： 使用Nginx反向代理Django提升负载能力。 使用uwsgi来进行请求的转发处理。 使用supervisord来进行uwsgi的自动启动。","categories":[],"tags":[]},{"title":"","slug":"腾讯云centos7搭建个人网站","date":"2019-08-31T01:21:49.646Z","updated":"2019-08-31T08:43:34.265Z","comments":true,"path":"2019/08/31/腾讯云centos7搭建个人网站/","link":"","permalink":"http://tanruidd.github.io/2019/08/31/腾讯云centos7搭建个人网站/","excerpt":"","text":"腾讯云CentOS7.6搭建个人网站首先，要有一个云服务器，我用的是CentOS7.6. 文件的上传与下载需要上传下载文件,需要使用rz和sz,但是安装后发现在putty使用不了. 查看官方文档:https://cloud.tencent.com/document/product/213/2131 通过WinSCP可以进行文件的上传下载. 安装相关软件安装JDK1yum -y install java-1.8.0-openjdk.x86_64 检查一下: 1java -version 安装Mysql据网上说yum上的的mysql资源有问题,所以不仅仅只用yum,需要使用其它命令获取mysq社区版. 下载: 1234mkdir downloadcd dowload/wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm 安装: 1yum install mysql mysql-server mysql-devel -y 结果速度太慢了,等不了,后面还是直接安装算了. 1yum install mysql 结果挂了. 找到一篇博客:https://www.cnblogs.com/yaowen/p/9486138.html 先试试. 123456rpm -pa | grep mysql //找出安装mysql的软件包和依赖包yum remove mysql-xxx-xxx- //依次删除find / -name mysql //查找配置文件rm -rf xxxx/xx/xx //依次删除 使用官网提供的mysql repo源: 使用WinSCP传到CentOS. 安装yum repo文件并更新yum缓存: 1rpm -ivh mysql57-community-release-el7-3.noarch.rpm 不行的话加两个参数: 1rpm -ivh mysql57-community-release-el7-3.noarch.rpm --nodeps --force 然后会在/etc/yum.repos.d/目录下生成两个repo文件mysql-community.repo mysql-community-source.repo 更新yum命令: 12yum clean allyum makecache 使用yum命令安装mysql 查看本地yum仓库中mysql版本: 1yum repolist all | grep mysql 安装mysql: 1yum install mysql-community-server 开启mysql服务: 12 获取初始密码: 1cat /var/log/mysqld.log | grep password 使用初始密码登录mysql: 12 修改初始密码: 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;Trtan@123456&apos;; 防火墙设置: CentOS7默认使用的是firewall作为防火墙，这里改为的iptables防火墙. 关闭firewall防火墙: 123systemctl stop firewalld.servicesystemctl disable firewalld.servicesystemctl mask firewalld.service 安装iptables防火墙: 12345678systemctl enable iptablessystemctl start iptables//编辑防火墙增加端口 防火墙文件位置为： /etc/sysconfig/iptablesvim /etc/sysconfig/iptables在倒数第三行上增加-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT 重启防火墙: 12systemctl enable iptables.servicesystemctl start iptables.service 将mysql服务加入到开机启动项: 12systemctl enable mysqld.servicesystemctl start mysqld.service 常用的mysql服务命令: 1234567登录mysql: mysql -u username -p退出mysql: quit启动mysql: systemctl start mysqld.service停止mysql: systemctl stop mysqld.service重启mysql: systemctl restart mysqld.service开机自启: systemctl enable mysqld.service查看版本号: select version(); Navicat连接Mysql修改mysql数据库下的user表中host的值: 更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”登录mysql数据库 : 1update user set host=&apos;%&apos; where user=&apos;root&apos;; 授权,赋予任何主机访问数据的权限: 12GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos;WITH GRANT OPTION;FLUSH PRIVILEGES; Navicat连接: 说实话,很坑,网上的教程大多不可行,选择一个准确的教程是真难… https://blog.csdn.net/qq_41210698/article/details/89817038 首先要配置云服务器,设定一个安全组, 10.0.0.0/0 TCP:3306 然后就可以在Navicat客户端设置连接属性了: 可能会有1251错误,mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password. 解决问题方法有两种： 方法1.升级navicat驱动；(我官网下载目前最新的Navicat 12 for MySQL是可以直接连上的) 方法2.把mysql用户登录密码加密规则还原成mysql_native_password. 这里采用方法2解决，具体操作步骤如下： 用如下命令查看用户信息,看plugin 1select host,user,plugin,authentication_string from mysql.user; 用如下命令修改密码: 1ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;newpassword&apos;; 这样回到客户端就可以成功连接了. 那么我们就有了一个远程的Mysql服务器了. 安装Tomcat9 首先去官网下载,在Core中的第二项,然后上传至CentOs. 12345cd /usr/localmkdir tomcatcd ~cd download/mv mv apache-tomcat-9.0.24.tar.gz /usr/local/tomcat 使用tar命令解压安装tomcat文件. 1tar -zxvf apache-tomcat-9.0.24.tar.gz 配置tomcat开机自启: 1234567891011121314cd /usr/lib/systemd/systemvi tomcat.service插入一下内容:Description=TomcatAfter=syslog.target network.target remote-fs.target nss-lookup.target [Service]Type=oneshotExecStart=/usr/local/tomcat/apache-tomcat-9.0.11/bin/startup.sh # 解压目录下的startup.shExecStop=/usr/local/tomcat/apache-tomcat-9.0.11/bin/shutdown.sh # 解压目录下的shutdown.shExecReload=/bin/kill -s HUP $MAINPIDRemainAfterExit=yes 然后: 1systemctl enable tomcat.service 其它相关命令: 12345systemctl start tomcat.service # 启动tomcatsystemctl stop tomcat.service # 关闭tomcat systemctl restart tomcat.service # 重启tomcat 启动和结束tomcat也可以到tomcat的安装目录的bin目录下执行shutdown.sh startup.sh来完成. 之后设置防火墙: 下面是firewall的, 12firewall-cmd --zone=public --list-ports # 查看防火墙开放的所有端口firewall-cmd --zone=public --add-port=8080/tcp --permanent # 添加开放端口 那么iptables的话就在/etc/sysconfig/iptables添加 123vim /etc/sysconfig/iptables在倒数第三行上增加-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT 然后可以查看 1iptables -L -n 使用 1ss -tnpl |grep 8080 可查看端口是否存在,是否成功启动. 然后访问ip:端口号即可访问主页. 总算是结束了,坑了一下午… 坑好多,有的就没记录,太费时间了,很难受. 可以修改tomcat端口,找到tomcat下conf/server.xml,修改为对应值就行了,不过得设置防火墙.","categories":[],"tags":[]},{"title":"","slug":"玩转腾讯云服务器","date":"2019-08-30T13:52:20.376Z","updated":"2019-08-31T01:11:45.738Z","comments":true,"path":"2019/08/30/玩转腾讯云服务器/","link":"","permalink":"http://tanruidd.github.io/2019/08/30/玩转腾讯云服务器/","excerpt":"","text":"8月30 腾讯云，免费体验15天，先试试。 然后1块钱买了个.xyz的域名。 登录：使用标准登录方式登录Linux官方文档：https://cloud.tencent.com/document/product/213/5436 操作场景（WeShell）： 优点： 支持快捷键复制粘贴 支持鼠标滚屏 支持中文输入法 安全性高，每次登录需要输入密码或密钥。 适用本地操作系统：Windows、Linux、Mac OS 前提条件：已经获取管理员账号及密码，可从站内信箱获取。 点击登录： 在弹出的窗口点击立即登录： 输入登录密码： 即进入到终端界面，成功连上云服务器： 使用ssh远程登录Linux操作场景： 在Linux或Mac OS系统的本地电脑通过SSH登录远程Linux。 适用本地操作系统：Linux、Mac OS 需要先创建SSH密钥： 登录云服务器控制台，在左侧导航栏，单击SSH密钥。 输入密钥名称，点击确定。 下载密钥。 再进行密钥的绑定： 在云服务器控制台，在左侧导航栏，单击SSH密钥。 选择要绑定的密钥。 待更新 使用远程登陆软件登录Linux官方文档：https://cloud.tencent.com/document/product/213/35699 下载 Windows 远程登录软件，即 PuTTY。点此获取 使用密码登录： 在 PuTTY Configuration 窗口中，输入以下内容。如下图所示： 要确保远程机器处于开机状态。 输入账号密码就登录了云服务器： 使用密钥登录： 打开PuTTY Key Generator： 点击load选择密钥文件： 点击Save private key，指定文件名后缀为.ppk 打开PuTTY，在左侧导航栏中，选择【Connection】&gt;【SSH】&gt;【Auth】，进入 Auth 配置界面。 选择密钥文件： 回到session，填写信息： 点击open，即可直接连接，无需输入密码： 那么就到这了。 下面进行ubuntu的可视化： ubuntu可视化12345sudo apt-get updatesudo apt-get install xinitsudo apt-get install gdm ( 登陆窗口，用于管理账户登陆的，还可以用来切换别的桌面环境。 )sudo apt-get install ubuntu-desktop 告辞！！！","categories":[],"tags":[]},{"title":"Android目录","slug":"Android目录","date":"2019-06-01T11:34:48.000Z","updated":"2019-06-01T11:45:23.366Z","comments":true,"path":"2019/06/01/Android目录/","link":"","permalink":"http://tanruidd.github.io/2019/06/01/Android目录/","excerpt":"","text":"目录结构： 123manifests //全局描述文件java //java源码文件res //资源文件（布局文件、图片资源文件） 1AndroidMainFest.xml 全局描述文件 12icon 应用图标label 应用标签 1activity配置 1234AppCompatActivity 带有actionbar的activityonCreate ： setContentView 指定布局文件 R文件，自动生成的，充当索引 1drawble目录 放置位图文件、xml资源文件、9 patch图片（9 patch工具生成的图片，可以报着图片不变形）","categories":[],"tags":[]},{"title":"Windows下Git的使用","slug":"Windows下Git的使用","date":"2019-05-27T02:33:59.000Z","updated":"2019-05-27T04:27:20.164Z","comments":true,"path":"2019/05/27/Windows下Git的使用/","link":"","permalink":"http://tanruidd.github.io/2019/05/27/Windows下Git的使用/","excerpt":"","text":"首先自行安装。 1git help -a //查看git提供了哪些命令 仓库命令首先在Git路径下Git Bash Here，因为使用cmd好像会出现有的命令识别不到。 1git show 我们先使用 1mkdir xxx 创建一个目录，然后cd到该目录下， 然后可以使用ll命令查看该目录下的资源内容， ll命令在cmd中就使用不了，所以我就用git bash了。 接着，使用 1git init 创建一个空的仓库，在当前目录中产生一个.git 的子目录。以后，所有的文件变化信息都会保存到这个目录下。 可以查看该目录结构 可以查看项目级别签名， 通过 12git config user.name xxxxgit config user.email xxxx 添加项目级别签名。 再次cat .git/config查看.git下面的config文件信息。 然后下面命令是创建系统级别签名的 12git config -global user.name xxxxgit config -global user.email xxxx 使用vim hello.txt添加一个hello.txt文件 使用 1git status 查看暂存区的文件状态，红色文字标记的文件表示工作区的文件待提交到暂存区，如下图所示： 通过 1git add 将工作区的文件提交到暂存区。 再次使用git status查看暂存区的文件状态，此时绿色标记的部分表示暂存区有个文件待提交到本地库。 通过 1git commit -m &quot;message&quot; hello.txt 将暂存区的文件提交到本地库。 再次git status查看暂存区文件状态，此时暂存区没有要提交的信息 通过 1git log 查看本地库的历史记录。 常用命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111) 远程仓库相关命令检出仓库：$ git clone git://github.com/jquery/jquery.git查看远程仓库：$ git remote -v添加远程仓库：$ git remote add [name] [url]删除远程仓库：$ git remote rm [name]修改远程仓库：$ git remote set-url --push [name] [newUrl]拉取远程仓库：$ git pull [remoteName] [localBranchName]推送远程仓库：$ git push [remoteName] [localBranchName] *如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：$git push origin test:master // 提交本地test分支作为远程的master分支$git push origin test:test // 提交本地test分支作为远程的test分支 2）分支(branch)操作相关命令查看本地分支：$ git branch查看远程分支：$ git branch -r创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支切换分支：$ git checkout [name]创建新分支并立即切换到新分支：$ git checkout -b [name]删除分支：$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并创建远程分支(本地分支push到远程)：$ git push origin [name]删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name] *创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)$git symbolic-ref HEAD refs/heads/[name]$rm .git/index$git clean -fdx 3）版本(tag)操作相关命令查看版本：$ git tag创建版本：$ git tag [name]删除版本：$ git tag -d [name]查看远程版本：$ git tag -r创建远程版本(本地版本push到远程)：$ git push origin [name]删除远程版本：$ git push origin :refs/tags/[name]合并远程仓库的tag到本地：$ git pull origin --tags上传本地tag到远程仓库：$ git push origin --tags创建带注释的tag：$ git tag -a [name] -m &apos;yourMessage&apos; 4) 子模块(submodule)相关操作命令添加子模块：$ git submodule add [url] [path] 如：$git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs初始化子模块：$ git submodule init ----只在首次检出仓库时运行一次就行更新子模块：$ git submodule update ----每次更新或切换分支后都需要运行一下删除子模块：（分4步走哦） 1) $ git rm --cached [path] 2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉 3) 编辑“ .git/config”文件，将子模块的相关配置节点删除掉 4) 手动删除子模块残留的目录 5）忽略一些文件、文件夹不提交在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如targetbin*.db 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Git 常用命令git branch 查看本地所有分支git status 查看当前状态 git commit 提交 git branch -a 查看所有的分支git branch -r 查看本地所有分支git commit -am &quot;init&quot; 提交并且加注释 git remote add origin git@192.168.1.119:ndshowgit push origin master 将文件给推到服务器上 git remote show origin 显示远程库origin里的资源 git push origin master:developgit push origin master:hb-dev 将本地库与服务器上的库进行关联 git checkout --track origin/dev 切换到远程dev分支git branch -D master develop 删除本地库developgit checkout -b dev 建立一个新的本地分支devgit merge origin/dev 将分支dev与当前分支进行合并git checkout dev 切换到本地dev分支git remote show 查看远程库git add .git rm 文件名(包括路径) 从git中删除指定文件git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来git config --list 看所有用户git ls-files 看已经被提交的git rm [file name] 删除一个文件git commit -a 提交当前repos的所有的改变git add [file name] 添加一个文件到git indexgit commit -v 当你用－v参数的时候可以看commit的差异git commit -m &quot;This is the message describing the commit&quot; 添加commit信息git commit -a -a是代表add，把所有的change加到git index里然后再commitgit commit -a -v 一般提交命令git log 看你commit的日志git diff 查看尚未暂存的更新git rm a.a 移除文件(从暂存区和工作区中删除)git rm --cached a.a 移除文件(只从暂存区中删除)git commit -m &quot;remove&quot; 移除文件(从Git中删除)git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)git diff --cached 或 $ git diff --staged 查看尚未提交的更新git stash push 将文件给push到一个临时空间中git stash pop 将文件从临时空间pop下来---------------------------------------------------------git remote add origin git@github.com:username/Hello-World.gitgit push origin master 将本地项目给提交到服务器中-----------------------------------------------------------git pull 本地与服务器端同步-----------------------------------------------------------------git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。git push origin serverfix:awesomebranch------------------------------------------------------------------git fetch 相当于是从远程获取最新版本到本地，不会自动mergegit commit -a -m &quot;log_message&quot; (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：git branch branch_0.1 master 从主分支master创建branch_0.1分支git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0git checkout branch_1.0/master 切换到branch_1.0/master分支du -hs-----------------------------------------------------------mkdir WebAppcd WebAppgit inittouch READMEgit add READMEgit commit -m &apos;first commit&apos;git remote add origin git@github.com:daixu/WebApp.gitgit push -u origin master 另外可以贴一个图： 可以见原著 ##windows下使用git和github建立远程仓库 我们要将上面的demo上传到github。 首先先建立远程仓库，此处的仓库名不一定需要和本地仓库名相同。 注意记住上面的ssh链接，最好不用http； 接着上git bash进行操作，操作之前先得进行密钥配对，我再搭博客时就已经配对完成了。 然后上传之前要对修改做一次总结。 1git commit -m &quot;xxxxxxxxx&quot; 然后需要将本地仓库和远程仓库建立连接： 1git remote add origin git@github.com:wylhyz/learngit.git origin是远程仓库在本地别名，你可以自由取，git链接是在建立远程仓库时要你记下的ssh连接。此句就是在本地建立远程仓库别名并链接到远程仓库。 然后使用如下命令就可以将更改上传了。 1git push -u origin master 此时在github仓库上查看发现上传成功了","categories":[],"tags":[]},{"title":"新主题来了","slug":"新主题来了","date":"2019-05-26T09:46:19.000Z","updated":"2019-05-26T09:55:05.526Z","comments":true,"path":"2019/05/26/新主题来了/","link":"","permalink":"http://tanruidd.github.io/2019/05/26/新主题来了/","excerpt":"miho – This is summary","text":"miho – This is summary","categories":[],"tags":[{"name":"First","slug":"First","permalink":"http://tanruidd.github.io/tags/First/"},{"name":"Second","slug":"Second","permalink":"http://tanruidd.github.io/tags/Second/"}]},{"title":"草稿测试","slug":"草稿测试","date":"2019-05-26T07:55:23.000Z","updated":"2019-05-26T07:55:23.354Z","comments":true,"path":"2019/05/26/草稿测试/","link":"","permalink":"http://tanruidd.github.io/2019/05/26/草稿测试/","excerpt":"","text":"这是草稿测试","categories":[],"tags":[]},{"title":"hexo配置","slug":"hexo配置","date":"2019-05-26T07:17:09.000Z","updated":"2019-05-26T15:41:42.963Z","comments":true,"path":"2019/05/26/hexo配置/","link":"","permalink":"http://tanruidd.github.io/2019/05/26/hexo配置/","excerpt":"","text":"Site1234567title: TR //网站标题subtitle: TR&apos;s Blog //网站副标题description: 学习永无止境 //网站描述keywords: //关键字,便于搜索引擎的搜索author: TR //您的名字language: zh-Hans //网站使用的语言timezone: //网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 URL1234567url: http://tanruidd.github.io //你需要把url改成你的网站域名root: / //网站根目录permalink: :year/:month/:day/:title/ //文章的永久链接格式, 比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。permalink_defaults: //永久链接中各部分的默认值 1theme: landscape //theme就是选择什么主题，也就是在theme这个文件夹下，在官网上有很多个主题，默认给你安装的是lanscape这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在theme文件夹下，再修改这个参数就可以了。 Deployment接下来这个deploy就是网站的部署的，repo就是仓库(Repository)的简写。branch选择仓库的哪个分支。 1234deploy: type: git repo: https://github.com/tanruidd/tanruidd.github.io branch: master layout(布局)123post //路径source/_postspage //路径sourcedraft //路径source/_drafts 如果你想另起一页，那么可以使用page 1hexo new page board 系统会自动给你在source文件夹下创建一个board文件夹，以及board文件夹中的index.md，这样你访问的board对应的链接就是http://xxx.xxx/board draft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以 1hexo new draft mypage 这样会在source/_draft中新建一个newpage.md文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用 1hexo server --draft 在本地端口中开启服务预览。 如果你的草稿文件写完了，想要发表到post中 1hexo publish draft newpage 就会自动把newpage.md发送到post中。 更改主题我找到了一个miho主题，看着还不错。 基本上创建主题的人都会有教程的，跟着做就好了。 设置评论系统12345gitment: owner: tanruidd #你的 GitHub ID repo: &apos;tanruidd.github.io&apos; #存储评论的 repo client_id: &apos;&apos; #client ID client_secret: &apos;&apos; #client secret 我是通过github的gitmet设置的评论系统 需要先在setting中最后一个建立一个OAuth App 将生成的id和secret放入相应位置即可。 操作之后发现不行，，，不能在自己域名下使用，只能在tanruidd.github.io下评论。 所以我又找了一个方法，valine评论。 首先需要注册leancloud账户，然后创建一个应用。 同样这里存在密钥，只不过我这个主题没有自带，所以我需要自己配置。 首先在\\miho\\_config.yml下增加 12345678valine: enable: true appid: #your App ID appkey: #your App Key notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 来啊，快活啊! pageSize: 10 对应位置填写。 然后找到\\miho\\layout\\_partial\\article.ejs文件，添加如下代码到最后 12345678910111213&lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt;&lt;section id=\"comments\" class=\"comments\"&gt; &lt;style&gt; .comments&#123;margin:30px;padding:10px;background:#fff&#125; @media screen and (max-width:800px)&#123;.comments&#123;margin:auto;padding:10px;background:#fff&#125;&#125; &lt;/style&gt; &lt;%- partial('plugins/comments/valine', &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;/section&gt;&lt;% &#125; %&gt; 在\\miho\\layout_partial\\plugins\\comments新建valine.ejs文件，输入下面内容。 123456789101112131415161718&lt;div id=\"vcomment\" class=\"comment\"&gt;&lt;/div&gt; &lt;script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"&gt;&lt;/script&gt;&lt;script src=\"//unpkg.com/valine/dist/Valine.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var notify = '&lt;%= theme.valine.notify %&gt;' == true ? true : false; var verify = '&lt;%= theme.valine.verify %&gt;' == true ? true : false; window.onload = function() &#123; new Valine(&#123; el: '.comment', notify: notify, verify: verify, app_id: \"&lt;%= theme.valine.appid %&gt;\", app_key: \"&lt;%= theme.valine.appkey %&gt;\", placeholder: \"&lt;%= theme.valine.placeholder %&gt;\", avatar:\"&lt;%= theme.valine.avatar %&gt;\" &#125;); &#125;&lt;/script&gt; 然后生成部署一下就行了。 SEO优化1SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。 推广是很麻烦的事情，怎么样别人才能知道我们呢，首先需要让搜索引擎收录你的这个网站，别人才能搜索的到。那么这就需要SEO优化了。","categories":[],"tags":[]},{"title":"hexo命令","slug":"hexo命令","date":"2019-05-26T06:18:18.000Z","updated":"2019-05-26T07:16:41.433Z","comments":true,"path":"2019/05/26/hexo命令/","link":"","permalink":"http://tanruidd.github.io/2019/05/26/hexo命令/","excerpt":"","text":"官方文档","categories":[],"tags":[]},{"title":"hexo图片问题","slug":"hexo图片问题","date":"2019-05-26T06:16:48.000Z","updated":"2019-05-26T07:02:20.170Z","comments":true,"path":"2019/05/26/hexo图片问题/","link":"","permalink":"http://tanruidd.github.io/2019/05/26/hexo图片问题/","excerpt":"","text":"上传图片不能显示 修改_config.yml 1post_asset_folder: true Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder 当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 在hexo的目录下执行npm install hexo-asset-image --save 下载一个插件。 hexo new &quot;xxx&quot;新建一个测试文件 会发现_post文件夹下还有一个同名文件夹。 这是需要你的图片路径是","categories":[],"tags":[]},{"title":"一步步搭建博客","slug":"github搭建博客","date":"2019-05-26T06:04:32.181Z","updated":"2019-05-26T07:06:17.057Z","comments":true,"path":"2019/05/26/github搭建博客/","link":"","permalink":"http://tanruidd.github.io/2019/05/26/github搭建博客/","excerpt":"","text":"前言和准备好久之前搭建过一次博客，现在已经忘的差不多了，借此重新搭建一下，顺便回顾一下。 首先我的github上面有我之前的博客项目，不过我想重新来一次，就先clone下来，然后删除该项目。 ​ 找到该项目的settings下的Delete this repository。 然后点击确认删除该项目 需要先装两个软件 git和node.js 这里注意git的安装 这样就可以在cmd中操作了，附一个git的安装教程链接，再附一个node.js的安装教程链接。 装好之后可以在命令窗口（Win+R， 输入CMD，回车）检查一下，输入和结果如下图所示就安装完成了。 配置 接着对git进行配置，创建ssh key。 在git中输入ssh-keygen -t rsa，接着按三次回车： 就会在相应位置生成id_rsa和id_rsa.pub这两个文件，前者是密钥，后者是公钥，用记事本打开id_rsa.pub，复制其中的全部内容，添加到GitHub上，这样本地的id_rsa密钥就可以和GitHub上的id_rsa.pub公钥进行配对，授权成功。 SSH key添加之后，就可以在本机输入ssh -T git@github.com进行测试 可以输入 12git config user.namegit config user.email ​ 如果不行 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; ​ 安装hexo任意新建一个文件夹，比如blog，然后cd到该路径下，或者直接在该文件夹下右键然后git Bash Here 输入npm install -g hexo安装hexo，等待一段时间即可。 接着输入hexo -v检查是否安装成功。 接着初始化hexo，输入hexo init 再安装npm，输入npm -install 我们的目录下就有下面的文件 每个目录及文件介绍 输入hexo s 打开hexo服务器，输入http://localhost:4000/我们可以看到如下页面： hexo g之后出现public文件夹 github创建个人仓库创建一个和你用户名相同的仓库，后面加github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxx.github.io。 将hexo部署到github打开站点配置文件 _config.yml，翻到最后，修改为 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 然后输入 123hexo clean //清除了你之前生成的东西hexo generate //生成静态文章，可以用 hexo g缩写hexo deploy //部署文章，可以用hexo d缩写 在输入hexo deploy时可能会需要登录，输入用户名和密码即可。 然后就能在GitHub上看到自己的项目了，也可以在http://tanruidd.github.io看到博客了。 设置个人域名注册一个阿里云账户，在阿里云买一个域名，我买的是.top结尾的，比较便宜。 选择域名 点解析 解析设置 添加解析 ip改成github的ip，ip从cmd中ping一下就得到了 登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名tanruidd.top 然后在你的博客文件source中创建一个名为CNAME文件，不要后缀，内容为你的域名。 最后在在git中输入 123hexo cleanhexo ghexo d 等待一段时间就可以在自己的域名看见博客了。 然后就是对博客的配置了，比如修改主题，可以根据需求自行修改。 可以查找hexo命令。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-05-26T04:48:53.199Z","updated":"2019-05-26T04:48:53.199Z","comments":true,"path":"2019/05/26/hello-world/","link":"","permalink":"http://tanruidd.github.io/2019/05/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://tanruidd.github.io/categories/Java/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://tanruidd.github.io/tags/leetcode/"},{"name":"Java正则","slug":"Java正则","permalink":"http://tanruidd.github.io/tags/Java正则/"},{"name":"First","slug":"First","permalink":"http://tanruidd.github.io/tags/First/"},{"name":"Second","slug":"Second","permalink":"http://tanruidd.github.io/tags/Second/"}]}